	static ship = {
		pos : [
			-0.6, 0.2, 0.3,  -0.4, 0.1, 0,  0.3, 0.1, 0,  0.6, 0.2, 0.3, // rump + side (4)
			-0.6, -0.2, 0.3,  -0.4, -0.1, 0,  0.3, -0.1, 0,  0.6, -0.2, 0.3, // rump - side (4)
			0.6, 0.2, 0.3,  0.3, 0.1, 0,  0.3, -0.1, 0,  0.6, -0.2, 0.3, // rump front (4)
			-0.6, 0.2, 0.3,  -0.4, 0.1, 0,  -0.4, -0.1, 0,  -0.6, -0.2, 0.3, // rump back (4)
			-0.6, 0.2, 0.3,  0.6, 0.2, 0.3,  0.6, -0.2, 0.3,  -0.6, -0.2, 0.3, // rump cover (4)
			0, 0.1, 0.3,  0, 0.1, 0.4,  0, 0, 1,  -0.2, 0, 0.4,  -0.05, 0.1, 0.4,  -0.05, 0.1, 0.3, // sail + side (6)
			0, -0.1, 0.3,  0, -0.1, 0.4,  0, 0, 1,  -0.2, 0, 0.4,  -0.05, -0.1, 0.4,  -0.05, -0.1, 0.3, // sail - side (6)
			0, -0.1, 0.3,  0, 0.1, 0.3,  0, 0, 1 // sail front (3)
		],
		norm : [
			0, 0.95, -0.32, 0, 0.95, -0.32, 0, 0.95, -0.32, 0, 0.95, -0.32, // r+s
			0, -0.95, -0.32, 0, -0.95, -0.32, 0, -0.95, -0.32, 0, -0.95, -0.32, // r-s
    		0.71, 0, -0.71, 0.71, 0, -0.71, 0.71, 0, -0.71, 0.71, 0, -0.71, // r f
    		-0.83, 0, -0.55, -0.83, 0, -0.55, -0.83, 0, -0.55, -0.83, 0, -0.55, // r b
    		0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, // r c
			-0.39, 0.91, 0.13, -0.39, 0.91, 0.13, -0.39, 0.91, 0.13, -0.39, 0.91, 0.13, -0.39, 0.91, 0.13, -0.39, 0.91, 0.13, // s+ 
			-0.39, -0.91, 0.13, -0.39, -0.91, 0.13, -0.39, -0.91, 0.13, -0.39, -0.91, 0.13, -0.39, -0.91, 0.13, -0.39, -0.91, 0.13,// s-
			1, 0, 0, 1, 0, 0, 1, 0, 0 // s f
		],
		tex : [
			0, 0, 1, 0, 1, 1, 0, 1,
			0, 0, 1, 0, 1, 1, 0, 1,
			0, 0, 1, 0, 1, 1, 0, 1,
			0, 0, 1, 0, 1, 1, 0, 1,
			0, 0, 1, 0, 1, 1, 0, 1,
			0, 0, 1, 0, 1, 1, 0, 0.5, 0, 1, 0, 1,
			0, 0, 1, 0, 1, 1, 0, 0.5, 0, 1, 0, 1,
			0, 0, 1, 0, 0.5, 1
		],
		idx : [
			0, 1, 2, 0, 2, 3,
			4, 5, 6, 4, 6, 7,
			8, 9, 10, 8, 10, 11,
			12, 13, 14, 12, 14, 15,
			16, 17, 18, 16, 18, 19,
			20, 21, 24, 20, 24, 25, 21, 22, 23,
			26, 27, 30, 26, 30, 31, 27, 28, 29,
			32, 33, 34
		]
	};







	# calculate all players road lengths and store them.
	# return the longest road length.
	# v 1.1c: phase-1: dfs find ends, phase-2: dfs lengths from ends.
	def calc_road_length(self): #, x=None, y=None):
		marked = [[0 for x in range(self.edge_dim_x)] for y in range(self.edge_dim_y)]
		ends = set()

		def is_mine(x,y,idx): 
			return self.edges[y][x] is not None and self.edges[y][x]['owner_index'] == idx
		def obstacle(x,y,idx): # someone elses town is in the way
			return self.edges[y][x] is not None and self.edges[y][x]['owner_index'] != idx
		def is_connected(c,e1,e2): # check that a ship and a road have a town between them
			if self.edges[e1[1]][e1[0]] is None or self.edges[e2[1]][e2[0]] is None: return False
			return is_mine(c[0],c[1],idx) or self.edges[e1[1]][e1[0]]['structure'] == self.edges[e2[1]][e2[0]]['structure']

		def dfs_ends(x,y,idx):
			marked[y][x] = 1
			result = set()

			for cx,cy in self.edge_adj_edges(x,y):
				if obstacle(cx,cy,idx):
					result |= {(cx,cy,idx)}
				else:
					branches = [ (ex,ey) for ex,ey in self.edge_adj_edges(cx,cy) if is_mine(ex,ey,idx) ]
					if len(branches) in [1,3] or not is_connected((cx,cy), branches[0], branches[1]):
						result |= {(cx,cy,idx)} 
					for ex,ey in branches:
						if marked[ey][ex] == 0:
							result |= dfs_ends(ex,ey,idx)
			
			return result

		def dfs_length(x,y,idx,avoid=None):
			if marked[y][x] == 2 or not is_mine(x,y,idx):
				return 0

			marked[y][x] = 2
			length = 1

			for cx,cy in self.edge_adj_edges(x,y):
				if avoid != (cx,cy) and marked[cy][cx] != 2 and not obstacle(cx,cy,idx):
					marked[cy][cx] = 2
					length += max([dfs_length(ex,ey,idx) for ex,ey in self.edge_adj_edges(cx,cy) if is_connected((cx,cy),(x,y),(ex,ey))]+[0])
					marked[cy][cx] = 1

			marked[y][x] = 1
			return length

		# re-evaluate for all players
		for player in self.players:
			player.road_max = 0

		for ey in range(self.edge_dim_y):
			for ex in range(self.edge_dim_x):
				edge = self.edges[ey][ex]
				if not self.is_crossing(ex,ey) and edge is not None and marked[ey][ex] == 0:
					idx = edge['owner_index']
					result = dfs_ends(ex,ey,idx) # search for endings
					cx,cy = self.edge_adj_edges(ex,ey)[0]
					ends |= {(cx,cy,idx)} if len(result) == 0 else result

		for cx,cy,idx in ends: 
			for ex,ey in self.edge_adj_edges(cx,cy):
				owner = self.players[idx]
				owner.road_max = max(owner.road_max, dfs_length(ex,ey,idx,(cx,cy)))

		return max([p.road_max for p in self.players])


				if (what == (q[i].id_type ?? q[i].what) && q[i].id_x == x && q[i].id_y == y) {
					const out = q[i];
					q[i] = q[q.length-1];
					q.pop();
					if (out.replace) {
						this.queue.push(out.replace);
					}
					return out;
				}



				// update available tiles
				if (numberPile) {
					this.available[`numbers${numberPile[1]}`] = obj.content.reduce((a,x) => a+x[1], 0)
				} else if (terrainPile) {
					const both = [this.situation[`_e_snumbers_terrains${terrainPile[1]}`] ?? 0, this.situation[`_e_sterrains${terrainPile[1]}`] ?? 0];
					this.available[`random_terrains${terrainPile[1]}`] = Math.min(...both.map((v) => v.reduce((a,x) => a+x[1], 0)));
				} 